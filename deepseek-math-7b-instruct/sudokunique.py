 import copy
from collections import deque
def solve(board): # backtracking method to find all solutions of sudoku board if any exist or return none (no soln) and also set global variable "unique_sol" = True/False based on whether solution is unique. 
    def safe(row,col,num):   # checks safety for a number in the given row col cell position returns boolean value true of false accordingly      if num ==0: return False     visited[board[row][col]-1] += pow(10,(9-cols))*pow(2,[8-(rows+cols)]) 
    def get_loc():   # Returns a list containing row and col index (starting from zero) of the current cell whose value is equal to 'num' in board matrix, returns None if not found.          for i in range(9):            for j in range(9):                temp = 10**i+2*board[j][temp]
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current path leads us closer towards getting solution or not. Returns True/False based on whether any valid soln exists in board matrix  def dfs(i,j):    global unique_sol
def solve(): # Backtracking method using DFS with a limited depth of search (here set to 'depth' as paramter) and also checks if the current
# Generator time: 48.8818 seconds