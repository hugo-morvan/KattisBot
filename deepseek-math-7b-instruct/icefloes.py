 import math
import sys
from itertools import combinations as comb
def dist(x,y): return (abs((p2[0]-p1[0])*(q2[1]-q1[1]))-(p2[1]-p1[1])*(q2[0]-q1[0]))/2.0  # Shoelace theorem
def area(x,y): return abs((sum([dist(*zip(a[-1:]+a[:-1],b[-1:]+b[:-1])) for a in zip(sorted(xy),cycle(xy))])+ dist(*zip(last2[0],first))))/  # Use the shoelace theorem on each polygon
def getArea(): return min([area_i() if area_i()>minDist else 'Scientists cannot meet' for i,poly in enumerate(polygons)])   # If a pair of points from different polygons is farther apart than d -> no solution. Also checks that the minimum distance wasn’t 0
def cycle(l): return (lambda: l[0]) if isinstance(l,(list)) else next(iter(l),'error')()                         # A generator function to yield successive elements from a list or iterator until error is reached, used for looping over vertices in polygons. If an actual iterable was passed as argument it will also handle stop iterations correctly
def distance_between(): return math.sqrt((p2[0]- p1[0])** 2 + (p2[1] - p1[1]) ** 2)                           # Euclidean Distance Formula used to calculate the minimum safe jump distance between two points on different polygons or scientists and their current position
def min_distance(x,y): return max([min((a if isinstance(a,(float)) else a.point)[0] for i in range (len(points)-1)  # Get all vertices of each point set except the last one to calculate distance between points on different polygons or scientists and their current position
                               for j,p2 in enumerate([l[i:] + [l[:i]]for l in x]+[[y]]) if i !=j])]     ,[])  # If no vertices then return an empty list else get the minimum value from all calculated distances. Used to set minDist as a safety net
def area_points(x, y):                                                                                   # Calculates and returns each polygon’s signed (clockwise vs counter-clockwise) relative position w/r current scientists location in relation with their safe jump distance d – if <=0 then inside the circle formed by that point otherwise outside it. Used to check for solutions
    xy = zip(x, y); last2=xy[-1:]+[xy]; first=[first_point] * len(last2)                                 # Returns a list of all points in each polygon’s coordinate system with the scientists position as reference point (0 – if inside circle else > or < zero accordingly). Used to check for solutions
def area_i(): return [area(*zip((p[1:] + p[:-1]) ,(q2+ q1) )), abs(((sum([distance_between()for i,j in comb(range (len(points)),  # Returns the signed position of all polygons’ points with reference to each other and their safe jump distance d. Used for solutions
                                 len(polygons))])-minDist)/2))] if max((p[1:] + p[: -                                                                           :-1]), *q) <= minDist else 'Scientists cannot meet'  # If any polygon is outside the circle of radius formed by scientists’ current position then return error message. Used to check for solutions
def polygons():return [poly_i() if len(p)>2 and p[0] == last[-1][-1:]else None   for i, poly in enumerate([last]+cycle([polygon]))  # Returns a list of all valid (more than two points) vertices’ combinations from each polygon with the scientists current position as reference point. Used to check solutions
def first_point(): return p if len(p)==2 else last[0]                                         # The only difference between this and above is that it checks for polygons less then 3 sides which can form a triangle (not necessarily an equilateral) with the scientists current position as reference point. Used to check solutions
def poly_i(): return [(points, cycle(polygon))] if len([*zip(*polygons)]) ==2 else [poly]     # Returns each polygon’s vertices and their corresponding points in relation w/r its safe jump distance d (current scientists location) as reference point. Used to check solutions
def last_point(): return p[-1:] +[p[:- 1]] if len(polygon)>2 else [points, cycle([polygon])]    # Returns the vertices of each polygon with their corresponding points in relation w/r its safe jump distance d (current scientists location) as reference point. Used to check solutions
def last(): return list(([*zip(*polygons)]))                                                 # A generator function that returns a tuple containing all combinations from polygons’ and first_point vertices, used for checking if any combination of points forms an equilateral triangle with the safe jump distance d (current scientists location) as reference point. Used to check solutions
def polygon(): return [tuple(item[0]) + ((minDist), )*len([ *zip(*polygons)][:-1] or []) for item in zip_longest(*points, fillvalue=())][: -2]+ [[last[- 1]]+ last ]      # Returns a list of all vertices combinations from each polygon and their corresponding points (scientists current position) as reference point. Used to check solutions
def poly(l): return [*zip_longest(*[list((item, ) + ([None]*(len([ *zip(*polygons)][:-1]) or [])) for item in zip_longest(*points, fillvalue=()))][: -2]+ [[last[- 1]]+ last ]), (l,)if len(polygon)>3 else None   # A generator function that returns a tuple containing all combinations from polygons’ vertices and their corresponding points as reference point. Used to check solutions
def zip_longest(*args, fillvalue=None): return [ *map(' '.join, itertools.zip_longest(*(reversed([a[-1:]+[b] for a in args]),fillvalue='')))]# Returns each vertex combination from polygons and their corresponding points (scientists current position) as reference point
points = [[0., 48329765.], [ -3,   ], [-      ,-     ]] # Coordinates of the first scientist’s location on two different floes in relation to its safe jump distance d(current scientistslocation). Used for checking if any combinationof points forms a triangle with it as reference point
polygon = [[0., 48], [ -3,   ], [-      ,-     ]] # Coordinates of the first scientist’s location on two different floes in relation to its safe jump distance d(current scientistslocation). Used for checking if any combinationof points forms a triangle with it as reference point
first_point = (0., 48)                                      # The only difference between this and above is thatit checksfor polygons less then three sides which can form atrianglewith thescientists current positionasreference point.Used to check solutions
# Generator time: 39.6752 seconds