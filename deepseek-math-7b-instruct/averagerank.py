 n, w = map(int, input().split())
points_per_competitor = [[] for _ in range(n)]
for week in range(w):
    competitors_gained_point = list(map(int, input().split()))[1:]
    points_in_this_week=[0]* (n+2) #index starts from 1 to n and added +ve for every competitor who gained point this week. This is done so that i can store index number directly in the list without any calculation later on while printing final answer(average rank).
    points=[]   #[competitor_no: no of times they got a chance]  e.g.: [1,2][3:] => means competitor with id = (n+1) has been given point once and second time but this is not in the form we need for calculating average rank
    points=[*points]*len(competitors_gained_point)+[0]*(w-len(competitors_gained_point))  #to make list of size w with each element having value (n+1) means that every competitor has been given point atleast once. This is done to avoid IndexError while calculating average rank
    for i,comp in enumerate(competitors_gained_point):#for all the competitors who gained a point this week iterate over their id's and increment points array by 1 (means they have got one chance) at that particular index.     #e.g.:[3:][0] => means competitor with id = comp(say=2, as per problem statement example in figure above ) has been given point once
        for j in range((w+n), 1 , -1):#start from (N + w) and go till n. This is done to avoid indexOutOfBound error while calculating average rank later on           #e.g.:[3:][0] => means competitor with id = comp(say=2, as per problem statement example in figure above ) has been given point once
            if j == (comp+1):#if current iteration is for the same participant who gained a score this week then increment his/her points by 1. This will be done till total w weeks are over             #e.g.:[3:][0] => means competitor with id = comp(say=2, as per problem statement example in figure above ) has been given point once
                if (points_in_this_week[(j-1)] != 0):#if participant got a score atleast one time before this week then we need to take care of the case when same competitor gains points again. This is done by incrementing his/her count in that particular row(corresponding id) only if it's not zero already             #e.g.:[3:][0] => means participant with id = 2 got point for first time this week and we need to consider the same while calculating average rank
                    points_in_this_week[(j-1)] +=  1#means they have another chance (to get a score) in next weeks. This is done so that their position on leaderboard can be calculated correctly after all w days are over             #e.g.:[3:][0] => means competitor with id = comp(say=2, as per problem statement example in figure above ) has been given point once
                else:#means participant got a score first time this week and we need to consider the same while calculating average rank           [points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))] #to store index number directly without any calculation later on
                points[(n+w)- j] +=  2#means they have got two chances to get a score and their position is at top of leader board. This will be done till total w weeks are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
            else: points[(n+w)- j] +=  0#means they have got zero chances to get a score and their position is at bottom of leader board. This will be done till total w weeks are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
            points[(n+w)- j] +=  0#means they have got no chances to get a score and their position is at bottom of leader board. This will be done till total w weeks are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
            if (w == points[(n+w)- j]): #if participant got a score last time this week and we need to consider the same while calculating average rank             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
                continue#means they have not been given point at all till now. This will be done so that their position on leaderboard can calculated correctly after total w days are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
            elif (w > points[(n+w)- j]):#means they have got one chance to get a score. This will be done so that their position on leaderboard can calculated correctly after total w days are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
                continue#means they have not been given point at all till now. This will be done so that their position on leaderboard can calculated correctly after total w days are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
            elif (w < points[(n+w)- j]):#means they have got more than one chance to get a score. This will be done so that their position on leaderboard can calculated correctly after total w days are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
                continue#means they have not been given point at all till now. This will be done so that their position on leaderboard can calculated correctly after total w days are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
            else: points[(n+w)- j] +=  0#means they have got zero chances to get a score and their position is at bottom of leader board. This will be done till total w weeks are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
        points[(n+w)- j] +=  0#means they have got no chances to get a score and their position is at bottom of leader board. This will be done till total w weeks are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
    points=list(reversed(sorted([0]*(n+2)+points))) #sort the list and reverse it so that first element has highest rank. This will be done till total w weeks are over             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
    points=list([0]*(n+2)+points)[:-(w)]#cut the extra (no of rows = n + w - total no.of participants who got a chance to get score till now), as we need only those scores which are <=1 million and >= 0 This will be done so that our answer is in correct format for printing average rank             #[points_per_competitor[int((j-1))].append(-i) for i  in range(len(comp))]
    points=[*range(*sorted([max(p - w, 0), min(w * (n + n+2)- len(set(points)), p]))for p in set(points)][::-1]#reversing the list so that first element has lowest rank This will be done to get average ranks correctly for each participant who got a chance till now
    #print([len(x)//w+1 if x else 0 for x in points_per_competitor]) this is used when we need not consider all w weeks. Only those participants whose score <= total no of competitors (n). This will be done so that our answer follows the same format as mentioned above
    average_rank=[len(x)//w+1 if x else 0 for x in points] #this is used when we need consider all w weeks. All those participants whose score <= total no of competitors (n). This will be done so that our answer follows the same format
# Generator time: 46.5202 seconds