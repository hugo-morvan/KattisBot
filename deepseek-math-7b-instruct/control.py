 N = int(input())
ingredients_used=[] #to keep track of ingredients used  in previous potions so that we dont use them again while making another potion because if a recipe contains an ingredient which was already been added to the cauldron ,it cant be concocted.So,we avoid adding such recipes into consideration and just move on
potions_made=0 #to keep track of how many potions were made  so far out of N potions possible . we start counting from zero since no potion has b een considered yet or been actually prepared/concocted as the case may be.Theres always a possibility that none couldbe concoctable
#recipe numbers starts with one but in python list indexation and looping conventions ,we count starting form 0 which is why we have initialized potions_made to zero before using it inside for loop . if no potion was made till now then its safe from being divided by N since denominator would be ZERO giving an undefined answer
for i in range(1,N+1): #recipe numbers start with one and go upto the given number of recipes 
    M = int(input())#M is for 'number'of ingredients required to make this recipe.No need to declare it as a variable since we are using only its value inside loop but not outside .We use local variables where possible so that they dont interfere with any other scope and do their job efficiently
    ing_req = list(map(int,input().split()))[1:] #all ingredients required for this recipe ,excluding first one 'M' which is the number of such ingredients  we need to prepare in cauldron.All integers are separated by a single space .We use slicing operation here (start=index_at+1;stop=+ve infinte) so that last element remains excluded i,e not part of returned list
    for j in range(len(ingredients_used),-1,-1):  #we iterate over the ingredients used array starting from its end and going till first position (inclusive).This way if we find any ingredient required by this recipe already present ,then that potion can't be concocted as per our condition .So, just return without adding it to potions_made list.
        for ing in ing_req: #ingredients are separated and iterated one at a time  inside the above mentioned loop (for j) over used ingredients array(list).If any of these matches with required ingredient ,then we can say that this potion cant be concocted since it requires an already added or present ingrediants to cauldron which was not part in previous recipe
            if ing ==ingredients_used[j]: #if current requred ingredient equals the one at same position of used ingredients list(array),then its a match .This potion can't be concocted as per our condition and we dont add it to potions made till now  so return from this loop itself
                break#no need for further checking ,just go back in outer 'for i lop'.No more potions will b e prepared which uses the same set of ingredients.This saves time since no other computation is done after breaking out of current iteration .We can save even space by not adding such recipes into consideration and just skipping to next one
        else: #if there was a mismatch in required ingredient (ing) inside inner for loop(for ing),means none matched so far till now.So, this potion CAN be concocted using only unused ingredients as per our condition .Add it the potions_made list  and move on to next recipe
            potions_made+=1 #as we have successfully prepared a new potion ,increase counter by one since its another successful attempt(out of N possible) till now.This way if no ingredient matched with any already used ones (ingredients in cauldron),all potions will be made and count would match total number given as input
            ingredients_used+=ing_req #now add all required ingredients for this recipe into our list which keeps track of those we have so far.So, these new set are now considered used ones  till next time when a potion is prepared using only unused ingrediants from the start .This way ,we save space and computation power since no extra ingredient(not part in previous recipes) need to be tracked for each recipe
print(potions_made)
# Generator time: 23.7245 seconds