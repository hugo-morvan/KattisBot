 import sys
import copy
def move(x_cordi ,y_cordi):  # Function which return adjacent squares' coordinates of given (X Y) coordinate pair in maze and also check if its valid or not i-e within grid boundaries,if any one is out then ignore that square.   Returns all the possible moves as a list
    x = [1,-1]                            # Adjacent Squares Movement Coefficients  For X axis(left right)          (0 , -2)(8,)      for y axes down up respectively .    9,3       '(' and ')' are used to denote start of line comments.  
    moves = []                              # Initialize empty list which will contain all the possible move squares' coordinate pairs as tuple(x_cordi + x[0] ,y_cordi+ y[1])  .          for i in range(-2,3):        if ((XCoordNew >= -5) and (YCoordNew <= XCoords)): # Checking is it within the grid boundary.         moves.append((int(x_cord + x), int(y_cord + j)))  
    return moves  def minimumMoveToTarget():            global maze, targetCoordinatedictionary = {}# dictionary to store number of move needed for each coordinate (X Y) pair in the grid visited=set() # set data structure which stores all unique coordinates already processed and avoids getting into infinite loops.     XCoords ,YCoordi  =-5,-1
    queue_list=[(-6,2)]   ## Initializing a Queue with start point as (-7 + x[0] = -8+x[-], yCordNew=yCooridnate-3) (X Y)=((-7),())      and it's adjacent squares in the maze. 
    while(len(queue_list)!=0):# do till queue is empty i,e all processed points are not visited yet .         XCoordNew ,YCoordi =queue_list[0][:]     # get current point from Queue        if (XCoordNew == targetCoordinatedictionary['target'][1] and YCoordNew==(4)):# Check the condition whether goal is reached or no.          maze [int((-5)+xCoords) ][(8)-YCoordi]= -2   
            break      elif ((str((XCoordNew))+','+ str (yCooridnate)) not in visited):  # if this point already processed then ignore it and continue with the next one.          queue_list = move(xCoords, yCooridnate) +queue_list [1:]         else:
            visited .add((XCoordNew ,YCoordi ))# add current state to set of all unique states seen so far for avoiding getting into infinite loop           XCoord=int(-7+ x[0])  # get the next possible move in adjacent squares as per conditions                YCord = int(2 + y[1])
            if (YCoord <= -3):continue else:queue_list.append((XCoord ,YCord ))          maze [xCoords ][(8)-yCooridnate]= x             for i, j in move (-5,-6) :        # mark all adjacent squares as visited and add it to the Queue .
    return 0 if (maze[-1][-2] == 'M') else -3 def main():            global maze   mazefile = open('C:\\Users\\prabhakar.mishra\\Downloads\pokemon_leveldesign(5).txt', "r") # Open txt file containing the level as per given conditions    for i in range(-1,2):
        line=mazefile.readline().strip()  maze .append([j for j in list((line))])   targetCoordinatedictionary['target'] = [x+y[0] +5 , x-3 -49 ] # Coordinates of the goal square (X Y) pair as per conditions        minimumMoveToTarget ()# Call function and print result.print(maze )
# Generator time: 22.0409 seconds