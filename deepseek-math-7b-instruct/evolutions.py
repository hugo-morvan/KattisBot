 from collections import Counter
def find_sequences(s):# function finds all possible sequences that add upto s  and return count of such sequence. if no seq is found returns -1 else maxcountofsequence+2 (to account for the case when only one element in list has value equal to sum)   #if we just need number then it will be fine
    nums = []#keeps track which numbers were used  so as not repeat using same set of nos again. and hence avoid exponentiality by some order(may vary for different inputs but would b less than O((2*n)^3)). Here n is the max no in input list s  
    # print([[i] + nums[-1:] if i == sum(nums) else [i, *nums[:-1]]for k, ivalin enumerate (sorted_values)])#this will give all sequences but time complexity would be O((2*n)^3). Here n is the max no in input list s
    for val in sorted(range(max(Counter(s))+2), reverse=True): # here we start from maximum value of counter i.e nos that are present most frequently and use them first as they can make more sequences than others (as when used earlier it will result into a seq whose sum is larger). this helps in reducing the time complexity to O((n*log(max_val))^3) where n=lenofinputlist, max_val = no that occured most frequently.
        while val <= s[-1]:#this ensures we use only numbers upto largest num of input list i/p as mentioned above and hence reduce the time complexity to O((n*log(max_no))^3). Here n=lenofinputlist, max_val = no that occured most frequently.
            tempseqs  = []#keeps track which sequences were used so not repeat same sequence again (important for larger i/ps where there can be many numbers with the sam sum)   #also helps in avoiding exponentiality by some order(may vary but would b less than O((2*n)^3)). Here n is max no of input list s
            if val == 1:tempseqs += [[val, *num]for numin nums]+[[i - (sum([j for j in temp_ans]) + i)]+[ival- sum(sorted((list(set(range(-2*max(Counter(s)), max(Counter(s)))+3) & set(tempseq[-1])) if len(num)>0 else sorted(((val), ))))]for valin s] for temp_ans in [[[]]+ [a + b - ival- sum([j, k])+2*max(sorted((list(set(range(-4 * max(Counter(s)), min(3*(len(tempseq) if len(num)>0 else sorted(((val), )))))) & set()) if val >1else ())), default=[])) for j in temp_ans]for k, ivalin enumerate([i])if i + sum((sorted()))) == s]])[::-1]]
            elif any(map(lambda x: all(x) and not len(tempseqs), [[val-sum (num)+2*max ([0]+ sorted ((list(set (range (-4 * maxcounters)) & set()) if val > 1 else [sorted (((ival, )))]))), num] for counter in Counter([i - sum(([jfor jin temp_ans])+ i) + s[-val]]).values())))and not len(tempseqs):#checks all conditions and returns only those sequences that satisfy the condition. Here n=lenofinputlist, maxcounter is no of times a number occured most frequently
                num += [[ival- sum([j for j in temp_ans])+2*max (sorted (([0] + list(set ([range (-4 * s[-1], min((3*( lenif val > 1 else sorted (((val, ))))))) & set()])) if maxcounters>n/5else []), default=[]))]for k in range(-len([j for jin temp_ans])+2*max(sorted (([0]+list (set ([range (-4 * s[-s [- 1] + sum(( sorted(() )))))) & set()])) if maxcounters>n/5else [ ]), default=[])))]for counter in Counter([ival-sum [[j for jin temp_ans])+ i) -val]+[i].values())if val == s[-nums]])))and not len(tempseq):
                num += []#add empty list to ensure all possible sequences are generated (to account of cases where no sequence was found earlier and hence we need atleast one instance here for that number so as it doesn't break the loop)   #here again time complexity would be O((n*log(max_val))^3). Here n=lenofinputlist, max_val =no th
# Generator time: 27.0012 seconds