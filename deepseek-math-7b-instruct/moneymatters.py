 def possible():
    n = int(input()) +1 # number if persons (0-indexed) including person to give money too, which is now an ownship for each friend and should not be included in the count of friends left with debts/owe mone  yto. Therefore we add one here: this will also ensure that n remains a valid upper limit when i gets initialized as -1
    o = [0]*n # array to hold how much is owed by each friend (or received from) including person who receives money at end of list, for whom no debt should be created.  Therefore initialize all values in this arrray with zero: if we didn't do so then the sum would not necessarily come out as expected and could cause us to mis-detect a solvable case
    m = int(input()) # number remaining friendhips (0 indexed) where friends still remain who are able/willing trade money.  We cannot assume these friendships will be in any order, only that they were all originally present for the group of n people before some left and debts got assigned to those not involved with trades
    total_owed = sum(o)-1 # start by initializing o[0] as -m because every friendship implies a debt equal tot he amount owed.  Therefore if we know that person i owes m, then each friend must have been originally paid back the equivalent of what they owe and some additional money which is returned to them in proportionate parts until everyone has received their original share (or close enough as determined by number precision). In this way total_owed will always be exactly zero.
    for i in range(m): # iterate through all possible friendships: 0 <= friendship pair < n, where we know that the first person owes money and second is willing to accept it so long they have not already been paid out of their own debt by other trades (friends who are partied with a debtor cannot be friends left over in which case this friend would only need pay back what was originally owed)
        f = list(map(int, input().split())) # read next friendship from stdin and split into two persons: 0 <= x < y <= n-1 (note we use -1 as upper limit here rather than the actual number of friends left because this will ensure that when i is incremented by one in each iteration its value remains a valid index for array o)
        total_owed += f[o] # add to current amount owed what was originally paid back (the difference between money received and original debt plus any additional funds returned).  This means the sum of all debts will always be exactly zero. Therefore if we can reach this point without encountering a negative value in o then it is safe for us assume that everyone owes enough so as to avoid creating more than one kind of transaction (i..e those who don't owe money and need not trade)
        total_owed -= f[1] # subtract the amount owed by person y from this sum.  This will ensure we do indeed end up with zero for all debts because any additional funds returned to friend x in previous transactions were subtracted out when computing current value of o: therefore once these have been accounted it is safe assume that every debt has a corresponding transaction
        if total_owed <0 : # check the overall sum.  If this becomes negative then one or more friends would need money from other debts not yet considered (because they are larger), so we cannot proceed further and should return an answer indicating IMPOSSIBLE solution: no way for everyone to get even
            break   
# Generator time: 18.8349 seconds